(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{463:function(e,t,r){"use strict";r.r(t);var o=r(2),v=Object(o.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"说一说你对vue响应式理解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#说一说你对vue响应式理解"}},[e._v("#")]),e._v(" 说一说你对vue响应式理解？")]),e._v(" "),t("p",[e._v("所谓的响应式就是我们能够根据数据的变化做出对应的响应机制")]),e._v(" "),t("p",[e._v("在vue中，当我们定义在响应式数据发生变化时，视图就会立即更新")]),e._v(" "),t("p",[e._v("vue2中，通过Object.defineProperty()的方式定义数据拦截，当数据被访问或发生变化时，我们感知并作出响应；然后如果是数组的话则是重写了数组对象原型上的7个方法，这种机制很好的解决了响应式数据的问题，但是实际使用中还是存在一些问问题，比如初始化的递归遍历造成的性能损失，得使用Vue.set/delete 新增删除属性才能做到对应的响应式处理，对于es6中新产生的Map、Set这些数据结构不支持等问题，对于这些数据结构的监听需要开发者自行实现（Vue.observable()）")]),e._v(" "),t("p",[e._v("而vue3中使用 proxy 来实现响应式，很好的解决了这些问题，Vue3的响应式具有惰性，具体来说，Vue3的响应式系统使用Proxy对象来代理原始数据对象，当访问代理对象的属性时，才会进行数据劫持和依赖收集。当数据变化时，Vue3会根据依赖关系进行有针对性的更新，这在多层次对象数据时尤其明显，因为只在访问对象的属性时才会进行数据劫持和依赖收集，而不是像Vue2那样进行全量更新，从而提高了性能。")]),e._v(" "),t("blockquote",[t("p",[e._v("当然你可以将reactive函数和ref函数的第二个参数设置为{ recursive: true }，这时Vue3会递归地将对象的所有属性都转换为响应式的，从而实现对对象的递归监听。")])]),e._v(" "),t("h2",{attrs:{id:"for-in、for-of和object-keys-区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#for-in、for-of和object-keys-区别"}},[e._v("#")]),e._v(" for in、for of和Object.keys 区别")]),e._v(" "),t("p",[e._v("for-in、for-of、Object.keys()都是用于遍历对象的属性或数组、字符串的方法，但它们之间有一些区别：")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("for-in遍历的是对象的可枚举属性，包括自身属性和继承属性，不适合遍历数组和字符串。")])]),e._v(" "),t("li",[t("p",[e._v("for-of遍历的是可迭代对象的元素，包括数组、字符串、Set、Map等，不适合遍历对象。")])]),e._v(" "),t("li",[t("p",[e._v("Object.keys()返回一个由对象的可枚举属性组成的数组，只遍历对象自身的属性，不包括继承属性，也不适合遍历其他类型的可迭代对象。")])]),e._v(" "),t("li",[t("p",[e._v("for-in和Object.keys()遍历的属性顺序是不确定的，而for-of遍历的元素顺序是确定的。")])])]),e._v(" "),t("p",[e._v("因此，如果需要遍历对象的自身属性，可以使用Object.keys()或for-in。如果需要遍历数组或字符串的元素，可以使用for-of。如果需要遍历对象的所有属性，包括继承属性，可以使用for-in。需要注意的是，for-in和Object.keys()不适合遍历其他类型的可迭代对象，例如Set和Map。")])])}),[],!1,null,null,null);t.default=v.exports}}]);