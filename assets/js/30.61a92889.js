(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{456:function(n,e,r){"use strict";r.r(e);var t=r(2),a=Object(t.a)({},(function(){var n=this,e=n._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("p",[n._v("1、什么是TypeScript？\nTypeScript是JavaScript的加强版，它给JavaScript添加了可选的静态类型和基于类的面向对象编程，它拓展了JavaScript的语法。")]),n._v(" "),e("p",[n._v("而且TypeScript不存在跟浏览器不兼容的问题，因为在编译时，它产生的都是JavaScript代码。")]),n._v(" "),e("p",[n._v("2、TypeScript 和 JavaScript 的区别是什么？\nTypescript 是 JavaScript 的超集，可以被编译成 JavaScript 代码。 用 JavaScript 编写的合法代码，在 TypeScript 中依然有效。Typescript 是纯面向对象的编程语言，包含类和接口的概念。 程序员可以用它来编写面向对象的服务端或客户端程序，并将它们编译成 JavaScript 代码。")]),n._v(" "),e("p",[n._v("TypeScript和 JavaScript的关系\nTypeScript 引入了很多面向对象程序设计的特征，包括：")]),n._v(" "),e("p",[n._v("interfaces  接口\nclasses  类\nenumerated types 枚举类型\ngenerics 泛型\nmodules 模块\n主要不同点如下：\nTS 是一种面向对象编程语言，而 JS 是一种脚本语言（尽管 JS 是基于对象的）。\nTS 支持可选参数， JS 则不支持该特性。\nTS 支持静态类型，JS 不支持。\nTS 支持接口，JS 不支持接口。")]),n._v(" "),e("p",[n._v("3为什么要用 TypeScript ？\nTS 在开发时就能给出编译错误， 而 JS 错误则需要在运行时才能暴露。\n作为强类型语言，你可以明确知道数据的类型。代码可读性极强，几乎每个人都能理解。\nTS 非常流行，被很多业界大佬使用。像 Asana、Circle CI 和 Slack 这些公司都在用 TS。")]),n._v(" "),e("p",[n._v("4、TypeScript 和 JavaScript 哪个更好？\n由于 TS 的先天优势，TS 越来越受欢迎。但是TS 最终不可能取代 JS，因为 JS 是 TS 的核心。")]),n._v(" "),e("p",[n._v("选择 TypeScript 还是 JavaScript 要由开发者自己去做决定。如果你喜欢类型安全的语言，那么推荐你选择 TS。 如果你已经用 JS 好久了，你可以选择走出舒适区学习 TS，也可以选择坚持自己的强项，继续使用 JS。")]),n._v(" "),e("p",[n._v("5、什么是泛型？\n泛型是指在定义函数、接口或类的时候，不预先指定具体的类型，使用时再去指定类型的一种特性。\n可以把泛型理解为代表类型的参数\n// 我们希望传入的值是什么类型，返回的值就是什么类型\n// 传入的值可以是任意的类型，这时候就可以用到 泛型")]),n._v(" "),e("p",[n._v("// 如果使用 any 的话，就失去了类型检查的意义")]),n._v(" "),e("p",[n._v("function createArray1(length: any, value: any): Array"),e("any",[n._v(" {\nlet result: any = [];\nfor (let i = 0; i < length; i++) {\nresult[i] = value;\n}\nreturn result;\n}")])],1),n._v(" "),e("p",[n._v("let result = createArray1(3, 'x');\nconsole.log(result);")]),n._v(" "),e("p",[n._v("// 最傻的写法：每种类型都得定义一种函数\nfunction createArray2(length: number, value: string): Array"),e("string",[n._v(" {\nlet result: Array"),e("string",[n._v(" = [];\nfor (let i = 0; i < length; i++) {\nresult[i] = value;\n}\nreturn result;\n}")])],1)],1),n._v(" "),e("p",[n._v("function createArray3(length: number, value: number): Array"),e("number",[n._v(" {\nlet result: Array"),e("number",[n._v(" = [];\nfor (let i = 0; i < length; i++) {\nresult[i] = value;\n}\nreturn result;\n}\n// 或者使用函数重载，写法有点麻烦\nfunction createArray4(length: number, value: number): Array"),e("number",[n._v("\nfunction createArray4(length: number, value: string): Array"),e("string",[n._v("\nfunction createArray4(length: number, value: any): Array"),e("any",[n._v(" {\nlet result: Array"),e("number",[n._v(" = [];\nfor (let i = 0; i < length; i++) {\nresult[i] = value;\n}\nreturn result;\n}\ncreateArray4(6, '666');\n//使用泛型\n// 有关联的地方都改成 "),e("T",[n._v("\nfunction createArray"),e("T",[n._v("(length: number, value: T): Array"),e("T",[n._v(" {\nlet result: T[] = [];\nfor (let i = 0; i < length; i++) {\nresult[i] = value;\n}\nreturn result;\n}\n// 使用的时候再指定类型\nlet result = createArray"),e("string",[n._v("(3, 'x');\n// 也可以不指定类型，TS 会自动类型推导\nlet result2 = createArray(3, 'x');\nconsole.log(result);\n6、TS中的类\nTypeScript 是面向对象的 JavaScript。而其中的类描述了所创建的对象共同的属性和方法。")])],1)],1)],1)],1)],1)],1)],1)],1)],1)],1),n._v(" "),e("p",[n._v("传统的JavaScript程序使用函数和基于原型的继承来创建可重用的组件，但这对于熟悉使用面向对象方式的程序员来说有些棘手，因为他们用的是基于类的继承并且对象是从类构建出来的。")]),n._v(" "),e("p",[n._v("从ECMAScript 2015，也就是ECMAScript 6，JavaScript程序将可以使用这种基于类的面向对象方法。在TypeScript里允许开发者现在就使用这些特性，并且编译后的JavaScript可以在所有主流浏览器和平台上运行，")]),n._v(" "),e("p",[n._v("7、什么是构造函数，构造函数作用是什么？\n构造函数 ，是一种特殊的方法。主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。而TypeScript的构造函数用关键字constructor来实现。可以通过this（和java/C#一样代表对象实例的成员访问）关键字来访问当前类体中的属性和方法。")]),n._v(" "),e("p",[n._v("8、实例化是什么？\n一般情况下，创建一个类后并不能直接的对属性和方法进行引用，必须对类进行实例化，即创建一个对象。TypeScript中用new 关键字创建对象。实例化后通过“.”来访问属性和方法")]),n._v(" "),e("p",[n._v("9、方法重写是什么？\n子类可继承父类中的方法，而不需要重新编写相同的方法。但有时子类并不想原封不动地继承父类的方法，而是想作一定的修改，这就需要采用方法的重写")]),n._v(" "),e("p",[n._v("重写的作用在于子类可以根据需要，定义特定于自己的行为。也就是说子类能够根据需要实现父类的方法。")]),n._v(" "),e("p",[n._v("10、什么是可索引类型接口？\n一般用来约束数组和对象")]),n._v(" "),e("p",[n._v("/ 数字索引——约束数组\n// index 是随便取的名字，可以任意取名\n// 只要 index 的类型是 number，那么值的类型必须是 string\ninterface StringArray {\n// key 的类型为 number ，一般都代表是数组\n// 限制 value 的类型为 string\n[index:number]:string\n}\nlet arr:StringArray = ['aaa','bbb'];\nconsole.log(arr);")]),n._v(" "),e("p",[n._v("// 字符串索引——约束对象\n// 只要 index 的类型是 string，那么值的类型必须是 string\ninterface StringObject {\n// key 的类型为 string ，一般都代表是对象\n// 限制 value 的类型为 string\n[index:string]:string\n}\nlet obj:StringObject = {name:'ccc'};\n11、什么是函数类型接口？\n对方法传入的参数和返回值进行约束\n// 注意区别")]),n._v(" "),e("p",[n._v("// 普通的接口\ninterface discount1{\ngetNum : (price:number) => number\n}")]),n._v(" "),e("p",[n._v('// 函数类型接口\ninterface discount2{\n// 注意:\n// “:” 前面的是函数的签名，用来约束函数的参数\n// ":" 后面的用来约束函数的返回值\n(price:number):number\n}\nlet cost:discount2 = function(price:number):number{\nreturn price * .8;\n}')]),n._v(" "),e("p",[n._v("// 也可以使用类型别名\ntype Add = (x: number, y: number) => number\nlet add: Add = (a: number, b: number) => a + b\n12、什么是类类型接口？\n如果接口用于一个类的话，那么接口会表示“行为的抽象”\n对类的约束，让类去实现接口，类可以实现多个接口\n接口只能约束类的公有成员（实例属性/方法），无法约束私有成员、构造函数、静态属性/方法")]),n._v(" "),e("p",[n._v("// 接口可以在面向对象编程中表示为行为的抽象\ninterface Speakable {\nname: string;")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v(' // ":" 前面的是函数签名，用来约束函数的参数\n// ":" 后面的用来约束函数的返回值\nspeak(words: string): void\n')])])]),e("p",[n._v("}")]),n._v(" "),e("p",[n._v("interface Speakable2 {\nage: number;\n}")]),n._v(" "),e("p",[n._v("class Dog implements Speakable, Speakable2 {\nname!: string;\nage = 18;")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("speak(words: string) {\n    console.log(words);\n}\n")])])]),e("p",[n._v("}")]),n._v(" "),e("p",[n._v("let dog = new Dog();\ndog.speak('汪汪汪');\n13、什么是混合类型接口？\n一个对象可以同时做为函数和对象使用")]),n._v(" "),e("p",[n._v("interface FnType {\n(getName:string):string;\n}")]),n._v(" "),e("p",[n._v("interface MixedType extends FnType{\nname:string;\nage:number;\n}\ninterface Counter {\n(start: number): string;\ninterval: number;\nreset(): void;\n}")]),n._v(" "),e("p",[n._v("function getCounter(): Counter {\nlet counter = "),e("Counter",[n._v("function (start: number) { };\ncounter.interval = 123;\ncounter.reset = function () { };\nreturn counter;\n}")])],1),n._v(" "),e("p",[n._v("let c = getCounter();\nc(10);\nc.reset();\nc.interval = 5.0;\n14、never 和 void 的区别？\nvoid 表示没有任何类型（可以被赋值为 null 和 undefined）。\nnever 表示一个不包含值的类型，即表示永远不存在的值。\n拥有 void 返回值类型的函数能正常运行。拥有 never 返回值类型的函数无法正常返回，无法终止，或会抛出异常。")]),n._v(" "),e("p",[n._v("15、TS的学前基础？\n因为 TypeScript 是对 JavaScript 的扩展，更准确的说是 ECMAScript。所以，我们学习我们这套 TypeScript 的课程，需要具备 ECMAScript 语言的基础：")]),n._v(" "),e("p",[n._v("熟悉语法基础（变量、语句、函数等基础概念）\n掌握内置对象（Array、Date 等）的使用\n面向对象基本概念（构造函数、原型、继承）")])])}),[],!1,null,null,null);e.default=a.exports}}]);